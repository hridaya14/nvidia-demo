analyze_codebase:
  description: |
    Perform an in-depth analysis of the research-oriented repository located at {repo_path}.
    The goal is to produce a technical overview that helps other researchers and developers
    quickly understand the entire codebase, including its architecture, logic, and experimental setup.

    The analysis must include:

    1. **File & Directory Structure Visualization**
       - Generate a clean, indented *directory tree chart* similar to what is typically seen in README files.
       - Clearly show the hierarchy of folders and files (e.g., `models/`, `datasets/`, `utils/`, `scripts/`).
       - Ignore the .git folder and any virtual environment directories (eg. /venv, /env , .env etc.).

    2. **Functional Understanding**
       - Determine what each file, script, and module contributes to the project (training, evaluation, dataset preprocessing, visualization, etc.).
       - Describe how modules depend on each other (e.g., model → dataloader → trainer).

    3. **Core Architecture**
       - Map the core architecture and components of the system (e.g., model architectures, data pipelines, training loops).
       - Explain research-specific designs (loss functions, model heads, evaluation metrics, etc.).

    4. **Key Classes, Functions, and Interactions**
       - Identify the main functions, classes, and their relationships.
       - Highlight custom algorithms or implementations that differ from standard approaches.

    5. **Data & Control Flow Diagrams**
       - Diagram or explain the data flow (e.g., dataset → model → metrics).
       - Show how control moves through the system during execution.

    6. **Design Patterns and Research Methodologies**
       - Identify any patterns or experimental frameworks (e.g., teacher–student setup, GAN training, self-supervised loops).
       - Mention practical design decisions relevant to reproducibility or scalability.

    7. **Ignore Non-Textual Files**
       - Exclude images, videos, model weights, or large data files.

    The final output should give an ML engineer or researcher a deep understanding of how the repository is organized and how it works as a research pipeline.

  expected_output: |
    A detailed technical report including:

      - **Repository Overview**: Purpose, goals, and research motivation.
      - **Directory Tree**: A visual chart of the file/folder hierarchy (like in README files).
      - **Component Summary**: Explanation of each module, file, and its role in the project.
      - **Codebase Walkthrough**:
        - Function/class summaries with parameter insights.
        - Inline usage examples in code blocks.
        - Common patterns (e.g., model registration, training loops).
      - **Architecture & Data Flow**:
        - Diagrams or structured explanations of how data and control move through the system.
      - **Experimental Setup**:
        - Description of how models are trained/tested, what datasets are used, and any special configurations.
      - **Design Patterns**:
        - Analysis of architectural or algorithmic design principles used in the research.

create_documentation_plan:
  description: |
    Based on the analysis of {repo_path}, create a structured **documentation roadmap**
    tailored for a research-focused codebase.

    The plan should propose a set of documentation files that cover the entire project
    from fundamentals to advanced usage, forming a logical learning path for future contributors.

    Each document entry should include:
      - A clear **title**
      - A **long, meaningful description**
      - **Prerequisites** (knowledge or setup required)
      - **Goals** (what the reader will learn or understand)
      - **Example code snippets** where relevant
      - The **intended audience** (e.g., new researchers, ML engineers, contributors)

    The documentation plan must cover:

      1. Comprehensive project overview and research goals.
      2. System architecture and core design decisions.
      3. Data pipeline documentation (dataset loading, preprocessing, augmentation).
      4. Model definitions and architecture explanations.
      5. Training and evaluation workflows.
      6. Experiment management (logging, metrics, checkpoints).
      7. Utilities and helper scripts.
      8. Reproducibility guidelines (environment, dependencies, seeds).
      9. Example notebooks or demo guides.
      10. Extending or modifying the codebase for new experiments.

    The final plan should be ordered by importance and complexity — starting from beginner-level
    introductions (overview, setup) and moving toward advanced technical deep-dives.

  expected_output: |
    A structured **documentation plan** containing:

      - **List of proposed documentation files**, each with:
        - Title
        - Description
        - Prerequisites
        - Code examples (if applicable)
        - Target audience
        - Expected outcome
      - **Recommended directory layout** (e.g., `/docs/architecture/`, `/docs/training/`, etc.)
      - Logical order of learning — from high-level concepts to detailed technical modules.
      - Notes on how to link between documents (cross-referencing architecture, model, and dataset sections).
